<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reveal Your Rank</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            touch-action: manipulation; /* Improves touch responsiveness on mobile */
        }
        
        #game-container {
            display: grid;
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto 1fr auto;
            gap: 4px;
            width: 100%;
            max-width: 500px; /* Max width for the core board area */
            margin: auto;
        }

        #game-board {
            grid-column: 2 / 3;
            grid-row: 2 / 3;
            aspect-ratio: 9 / 12; /* Maintain board proportions */
            background-size: cover;
            background-position: center;
        }
        
        .coord {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: #9ca3af; /* gray-400 */
        }
        #col-labels { grid-column: 2 / 3; grid-row: 1 / 2; display: flex; }
        #col-labels-bottom { grid-column: 2 / 3; grid-row: 3 / 4; display: flex; }
        #row-labels { grid-column: 1 / 2; grid-row: 2 / 3; display: flex; flex-direction: column; }
        #row-labels-right { grid-column: 3 / 4; grid-row: 2 / 3; display: flex; flex-direction: column; }
        .coord-item { flex: 1; display:flex; align-items:center; justify-content:center; }


        .cell { 
            position: relative; 
            background-size: cover;
            background-position: center;
        }
        .cell-content {
            position: absolute; top:0; left:0; right:0; bottom:0;
            display: flex; align-items: center; justify-content: center;
            font-size: clamp(14px, 3.5vw, 24px); /* Responsive font size */
            font-weight: bold;
            transition: transform 0.3s ease-in-out;
            z-index: 10;
        }
        .cell-content img {
            width: 90%;
            height: 90%;
            object-fit: contain;
        }

        /* Unit & Terrain Styling */
        .player-unit { background-color: #3b82f6; color: white; border-radius: 0.25rem; } /* blue-500 */
        .rival-unit { background-color: #ef4444; color: white; border-radius: 0.25rem; } /* red-500 */
        .castle { background-color: #facc15; } /* yellow-400 */
        .mine { background-color: #4b5563; } /* gray-600 */
        .water { 
            background-color: #0e7490; /* cyan-700 */
            background-size: cover;
            background-position: center;
        }
        
        .cell::after {
            content: '';
            position: absolute;
            top: 0; right: 0; bottom: 0; left: 0;
            z-index: 12;
            pointer-events: none;
            transition: background-color 0.3s;
            border-radius: 0.125rem;
        }

        .selected::after {
            background-color: rgba(22, 163, 74, 0.9); /* green-600 with 90% opacity */
            box-shadow: 0 0 0 3px #10b981 inset;
        }
        
        .valid-move::after { 
            background-color: rgba(59, 130, 246, 0.9); /* blue-500 with 90% opacity */
            cursor: pointer;
        }
        .attack-move::after { 
            background-color: rgba(239, 68, 68, 0.9); /* red-500 with 90% opacity */
            cursor: pointer; 
        }
        .unknown-rival::after {
            background-color: rgba(107, 114, 128, 0.5); /* gray-500 with 50% opacity */
        }
        
        @keyframes pulse-yellow {
             0%, 100% { box-shadow: 0 0 0 2px rgba(234, 179, 8, 0); }
             50% { box-shadow: 0 0 0 2px rgba(234, 179, 8, 0.7); }
        }
        .last-move-from::after, .last-move-to::after {
            animation: pulse-yellow 1.5s infinite;
        }

        .cheated-reveal { opacity: 0.6; }

        /* Turn Indicator Styling */
        .turn-active {
            box-shadow: 0 0 10px 3px #10b981; /* emerald-500 */
            border: 1px solid #10b981;
        }

        /* Modal Styling */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.6); display: flex;
            align-items: center; justify-content: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 2rem; border-radius: 0.5rem; text-align: left;
            max-width: 90%; width: 500px;
        }
        
        #log-container { height: 150px; }
        #unit-info-panel { height: 100px; }
        .gemini-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Tab Interface Styling */
        .tab { padding: 0.5rem 1rem; cursor: pointer; border-bottom: 2px solid transparent; }
        .tab-active { border-bottom-color: #3b82f6; color: #3b82f6; } /* blue-500 */
        .tab-content { display: none; }
        .tab-content-active { display: block; }
        #sprite-setup-form {
            max-height: 400px; /* Or adjust as needed */
            overflow-y: auto;
        }
        .sprite-info-item .tooltip {
            display: none;
        }
        .sprite-info-item:hover .tooltip {
            display: block;
        }
        .modal-body-scrollable {
            max-height: 70vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-800 text-white flex flex-col items-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-7xl mx-auto flex flex-col lg:flex-row gap-4">
        <!-- Left Panel: Game Board and Info -->
        <div class="flex-grow">
            <div class="flex justify-between items-center mb-2 p-2 bg-gray-700 rounded-lg flex-wrap gap-2">
                <div>
                    <h1 class="text-xl sm:text-2xl font-bold">Reveal Your Rank</h1>
                    <p id="turn-indicator" class="text-lg text-blue-400">Player's Turn</p>
                </div>
                 <div class="flex items-center gap-2 flex-wrap">
                    <label for="ruleset-selector" class="text-sm">Rules:</label>
                    <select id="ruleset-selector" class="bg-gray-600 text-white rounded p-1 text-sm">
                        <option value="reveal" selected>Reveal Your Rank</option>
                        <option value="stratego">Stratego</option>
                    </select>
                    <label for="ai-difficulty" class="text-sm">Rival AI:</label>
                    <select id="ai-difficulty" class="bg-gray-600 text-white rounded p-1 text-sm">
                        <option value="low">Low</option>
                        <option value="medium" selected>Medium</option>
                        <option value="high">High</option>
                    </select>
                     <label for="sim-speed" class="text-sm">Speed:</label>
                    <select id="sim-speed" class="bg-gray-600 text-white rounded p-1 text-sm">
                        <option value="1000">1x</option>
                        <option value="500">2x</option>
                        <option value="250">4x</option>
                    </select>
                    <button id="simulate-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Simulate</button>
                    <button id="reset-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">New Game</button>
                </div>
            </div>
            
            <div id="game-container">
                <div id="col-labels" class="coord"></div>
                <div id="row-labels" class="coord"></div>
                <div id="game-board" class="w-full bg-gray-900 grid grid-cols-9 border-2 border-gray-600 rounded-lg overflow-hidden">
                    <!-- Cells generated by JS -->
                </div>
                <div id="row-labels-right" class="coord"></div>
                <div id="col-labels-bottom" class="coord"></div>
            </div>
             <div id="message-area" class="mt-2 text-center p-2 bg-gray-700 rounded-lg text-lg h-auto min-h-[3rem] flex items-center justify-center">
                Select a unit to move.
            </div>
        </div>

        <!-- Right Panel: Tabs -->
        <div class="w-full lg:w-80 flex-shrink-0 bg-gray-700 p-3 rounded-lg">
            <div class="flex border-b border-gray-500 mb-2 flex-wrap">
                <div data-target="status" class="tab tab-active">Status/Log</div>
                <div data-target="reference" class="tab">Reference</div>
                <div data-target="setup" class="tab">Setup</div>
                <div data-target="sprites" class="tab">Sprites</div>
            </div>
            <!-- Status/Log Content -->
            <div id="tab-content-status" class="tab-content tab-content-active">
                <h2 class="text-xl font-bold mb-2">Status</h2>
                <div class="grid grid-cols-2 gap-2 mb-3 text-lg">
                    <div id="player-status-panel" class="text-center bg-gray-800 p-2 rounded-lg transition-all">
                        <span class="text-blue-400 font-bold">Player Units</span>
                        <p id="player-unit-count" class="text-2xl">0</p>
                    </div>
                    <div id="rival-status-panel" class="text-center bg-gray-800 p-2 rounded-lg transition-all">
                        <span class="text-red-400 font-bold">Rival Units</span>
                        <p id="rival-unit-count" class="text-2xl">0</p>
                    </div>
                </div>

                <div class="flex justify-between items-center mb-2">
                     <h2 class="text-xl font-bold">Move Log</h2>
                </div>
                <div id="log-container" class="bg-gray-800 rounded p-2 overflow-y-auto text-sm space-y-1"></div>
                 <h2 class="text-xl font-bold mb-2 mt-2 border-t border-gray-500 pt-2">Selected Unit</h2>
                <div id="unit-info-panel" class="bg-gray-800 rounded p-2 overflow-y-auto text-sm">
                    <p class="text-gray-400">Select a unit to see its details.</p>
                </div>
            </div>
            <!-- Reference Content -->
            <div id="tab-content-reference" class="tab-content">
                 <h2 class="text-xl font-bold mb-2">Unit Reference</h2>
                 <p class="text-sm mb-4">This diagram shows the named sides of a unit for rule reference.</p>
                 <div class="space-y-4">
                     <!-- Rival Unit -->
                     <div class="bg-gray-800 p-2 rounded-lg text-center text-xs">
                        <div class="font-bold text-red-400 mb-2">Rival Unit</div>
                        <div class="mb-1">Back</div>
                        <div class="flex items-center justify-center gap-1">
                            <div>Left</div>
                            <div class="w-12 h-12 bg-red-500 flex items-center justify-center font-bold text-lg rounded">R</div>
                            <div>Right</div>
                        </div>
                        <div class="mt-1 font-bold text-green-400">Front</div>
                     </div>
                     <!-- Player Unit -->
                     <div class="bg-gray-800 p-2 rounded-lg text-center text-xs">
                        <div class="font-bold text-blue-400 mb-2">Player Unit</div>
                        <div class="mb-1 font-bold text-green-400">Front</div>
                        <div class="flex items-center justify-center gap-1">
                            <div>Left</div>
                            <div class="w-12 h-12 bg-blue-500 flex items-center justify-center font-bold text-lg rounded">P</div>
                            <div>Right</div>
                        </div>
                        <div class="mt-1">Back</div>
                     </div>
                 </div>
            </div>
            <!-- Setup Content -->
            <div id="tab-content-setup" class="tab-content">
                <h2 class="text-xl font-bold mb-2">Army Composition</h2>
                <div id="army-setup-form" class="space-y-2 text-sm">
                    <!-- Inputs will be generated here -->
                </div>
                <div class="mt-3 pt-3 border-t border-gray-500 text-sm">
                    <p>Total Units: <span id="setup-total-units">0</span> / 36</p>
                </div>
            </div>
            <!-- Sprites Content -->
            <div id="tab-content-sprites" class="tab-content">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">Theme</h2>
                    <button id="sprite-info-button" class="bg-sky-500 hover:bg-sky-600 rounded-full w-6 h-6 flex items-center justify-center text-white font-bold text-sm">i</button>
                 </div>
                <select id="sprite-preset-selector" class="w-full bg-gray-600 text-white rounded p-1 text-sm mb-4">
                    <option value="default" selected>Default (Emojis)</option>
                    <option value="medieval">Medieval</option>
                    <option value="fantasy">Fantasy</option>
                    <option value="sci-fi">Sci-Fi</option>
                    <option value="ww2">WW2</option>
                    <option value="custom">Custom URLs</option>
                </select>
                <div id="custom-sprite-inputs-wrapper" class="hidden">
                    <h3 class="text-lg font-bold mb-2 border-t border-gray-500 pt-2">Custom Sprite URLs</h3>
                    <div id="sprite-setup-form" class="space-y-2 text-sm">
                        <!-- Sprite inputs will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Modal -->
    <div id="main-modal" class="modal-overlay hidden">
        <div id="main-modal-content" class="modal-content text-gray-800">
            <h2 id="main-modal-title" class="text-3xl font-bold mb-4 text-center"></h2>
            <div id="main-modal-body" class="text-base mb-6 prose max-w-full"></div>
            <button id="main-modal-close-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg w-full">Close</button>
        </div>
    </div>
    
    <script>
    // --- GAME CONFIGURATION AND CONSTANTS ---
    const ROWS = 12;
    const COLS = 9;
    const PLAYER_ID = 'player';
    const RIVAL_ID = 'rival';

    const UNITS = {
        CASTLE: { name: 'Castle (Flag)', symbol: '🏰', level: 0, immobile: true, id: 'castle', description: 'Your main objective. If captured, you lose. It cannot move.' },
        MINE: { name: 'Mine', symbol: '💣', level: 99, immobile: true, id: 'mine', description: 'An immobile trap. Destroys any unit that attacks it, except for an Engineer.' },
        WATER: { name: 'Water', symbol: '🌊', level: 1000, immobile: true, id: 'water', description: 'Impassable terrain.' },
        ENGINEER: { name: 'Engineer', symbol: 'E', level: 1, id: 'engineer', description: 'The only unit that can safely disarm Mines.' },
        SCOUT: { name: 'Scout', symbol: '🐎', level: 1, id: 'scout', description: 'Can move any number of open squares in a straight line, vertically or horizontally.' },
        KNIGHT_1: { name: 'Knight (Lv 1)', symbol: 'K1', level: 1, id: 'knight_1', description: 'A basic fighting unit.' },
        KNIGHT_2: { name: 'Knight (Lv 2)', symbol: 'K2', level: 2, id: 'knight_2', description: 'A standard fighting unit.' },
        KNIGHT_3: { name: 'Knight (Lv 3)', symbol: 'K3', level: 3, id: 'knight_3', description: 'A seasoned fighting unit.' },
        KNIGHT_4: { name: 'Knight (Lv 4)', symbol: 'K4', level: 4, id: 'knight_4', description: 'An experienced fighting unit.' },
        KNIGHT_5: { name: 'Knight (Lv 5)', symbol: 'K5', level: 5, id: 'knight_5', description: 'A veteran fighting unit.' },
        KNIGHT_6: { name: 'Knight (Lv 6)', symbol: 'K6', level: 6, id: 'knight_6', description: 'An elite fighting unit.' },
        KNIGHT_7: { name: 'Knight (Lv 7)', symbol: 'K7', level: 7, id: 'knight_7', description: 'A battle-hardened fighting unit.' },
        KNIGHT_8: { name: 'Knight (Lv 8)', symbol: 'K8', level: 8, id: 'knight_8', description: 'A champion fighting unit.' },
        KNIGHT_9: { name: 'Knight (Lv 9)', symbol: 'K9', level: 9, id: 'knight_9', description: 'A heroic fighting unit.' },
        MORTIR: { name: 'Mortir', symbol: 'M10', level: 10, id: 'mortir', description: 'The most powerful movable unit on the battlefield. Can defeat any unit except a Mine.' },
    };

    const REVEAL_ARMY_COMPOSITION = [
        { unit: UNITS.CASTLE, quantity: 1 }, { unit: UNITS.MINE, quantity: 4 },
        { unit: UNITS.ENGINEER, quantity: 4 }, { unit: UNITS.SCOUT, quantity: 3 },
        { unit: UNITS.KNIGHT_2, quantity: 4 }, { unit: UNITS.KNIGHT_3, quantity: 4 },
        { unit: UNITS.KNIGHT_4, quantity: 3 }, { unit: UNITS.KNIGHT_5, quantity: 3 },
        { unit: UNITS.KNIGHT_6, quantity: 3 }, { unit: UNITS.KNIGHT_7, quantity: 2 },
        { unit: UNITS.KNIGHT_8, quantity: 2 }, { unit: UNITS.KNIGHT_9, quantity: 2 },
        { unit: UNITS.MORTIR, quantity: 1 },
    ];
    
    const STRATEGO_ARMY_COMPOSITION = [
        { unit: UNITS.CASTLE, quantity: 1 }, { unit: UNITS.MINE, quantity: 4 },
        { unit: UNITS.ENGINEER, quantity: 4 }, { unit: UNITS.SCOUT, quantity: 4 },
        { unit: UNITS.KNIGHT_1, quantity: 3 }, { unit: UNITS.KNIGHT_2, quantity: 4 },
        { unit: UNITS.KNIGHT_3, quantity: 3 }, { unit: UNITS.KNIGHT_4, quantity: 3 },
        { unit: UNITS.KNIGHT_5, quantity: 2 }, { unit: UNITS.KNIGHT_6, quantity: 1 },
        { unit: UNITS.KNIGHT_7, quantity: 2 }, { unit: UNITS.KNIGHT_8, quantity: 2 },
        { unit: UNITS.KNIGHT_9, quantity: 2 }, { unit: UNITS.MORTIR, quantity: 1 },
    ];

    const THEME_BASE_URL = 'https://machupicchu.lt/game-demo/';
    const THEMES = {
        default: { name: 'Default', assets: {} },
        medieval: { name: 'Medieval' },
        fantasy: { name: 'Fantasy' },
        'sci-fi': { name: 'Sci-Fi' },
        ww2: { name: 'WW2' },
    };
    
    function getThemeAssets(themeKey) {
        if (themeKey === 'default' || !THEMES[themeKey]) return { general: {}, player: {}, rival: {}, sounds: {} };
        const baseUrl = `${THEME_BASE_URL}${themeKey}/`;
        
        const assets = {
            general: {
                grass: `${baseUrl}general/grass.png`,
                water: `${baseUrl}general/water.png`,
                fire: `${baseUrl}general/fire.png`,
                victory: `${baseUrl}general/victory.png`,
            },
            player: {},
            rival: {},
            sounds: {
                fightStart: `${baseUrl}sounds/fight-start.wav`,
                death: `${baseUrl}sounds/death.wav`,
                newGame: `${baseUrl}sounds/new-game.wav`,
                victory: `${baseUrl}sounds/victory.wav`,
            }
        };

        for (const unit of Object.values(UNITS)) {
            if (unit.id === 'water') continue;
            const filename = `${unit.id.replace(/_/g, '-')}.png`;
            assets.player[unit.id] = `${baseUrl}player/${filename}`;
            assets.rival[unit.id] = `${baseUrl}rival/${filename}`;
        }
        return assets;
    }


    // --- DOM ELEMENT REFERENCES ---
    const dom = {
        gameBoard: document.getElementById('game-board'),
        turnIndicator: document.getElementById('turn-indicator'),
        messageArea: document.getElementById('message-area'),
        resetButton: document.getElementById('reset-button'),
        simulateButton: document.getElementById('simulate-button'),
        modal: document.getElementById('main-modal'),
        modalTitle: document.getElementById('main-modal-title'),
        modalBody: document.getElementById('main-modal-body'),
        modalCloseButton: document.getElementById('main-modal-close-button'),
        logContainer: document.getElementById('log-container'),
        playerUnitCountEl: document.getElementById('player-unit-count'),
        rivalUnitCountEl: document.getElementById('rival-unit-count'),
        playerStatusPanel: document.getElementById('player-status-panel'),
        rivalStatusPanel: document.getElementById('rival-status-panel'),
        rulesetSelector: document.getElementById('ruleset-selector'),
        aiDifficultySelector: document.getElementById('ai-difficulty'),
        simSpeedSelector: document.getElementById('sim-speed'),
        armySetupForm: document.getElementById('army-setup-form'),
        spriteSetupForm: document.getElementById('sprite-setup-form'),
        spritePresetSelector: document.getElementById('sprite-preset-selector'),
        customSpriteInputsWrapper: document.getElementById('custom-sprite-inputs-wrapper'),
        spriteInfoButton: document.getElementById('sprite-info-button'),
        unitInfoPanel: document.getElementById('unit-info-panel'),
    };

    // --- CENTRAL GAME STATE ---
    let gameState = {};
    let soundEngine = {};

    // --- ENGINE CORE: STATE MANAGEMENT & RENDERING ---

    /**
     * Resets the game state to its initial configuration.
     */
    function resetGameState() {
        gameState = {
            grid: Array(ROWS).fill(null).map(() => Array(COLS).fill(null)),
            currentPlayer: PLAYER_ID,
            selectedUnit: null,
            lastMove: null,
            gameOver: false,
            simulationActive: false,
            isAnimating: false,
            cheatModeActive: false,
            ruleset: dom.rulesetSelector.value,
            aiDifficulty: dom.aiDifficultySelector.value,
            turnNumber: 1,
            activeSprites: getActiveSprites(),
        };
    }

    /**
     * The single source of truth for drawing the UI based on the current gameState.
     */
    function render() {
        renderBoard();
        renderUI();
    }
    
    /**
     * Renders the game board cells, units, selection, and valid moves.
     */
    function renderBoard() {
        dom.gameBoard.innerHTML = '';
        dom.gameBoard.style.backgroundImage = 'none';
        dom.gameBoard.style.backgroundColor = '#111827'; // bg-gray-900 default
        
        const validMoves = gameState.selectedUnit ? getValidMoves(gameState.selectedUnit) : [];
        
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell border border-gray-700';
                cell.dataset.r = r;
                cell.dataset.c = c;

                const cellContent = document.createElement('div');
                cellContent.className = 'cell-content';
                const unit = gameState.grid[r][c];
                
                // Apply grass to all non-water cells when a sprite theme is active
                if (gameState.activeSprites.general?.grass && (!unit || unit.name !== 'Water')) {
                    cell.style.backgroundImage = `url('${gameState.activeSprites.general.grass}')`;
                }


                if (unit) {
                    const isPlayerViewRevealed = unit.revealed || unit.owner === PLAYER_ID || gameState.simulationActive || gameState.cheatModeActive;
                    let spriteUrl;
                    if(isPlayerViewRevealed) {
                        spriteUrl = unit.owner === PLAYER_ID 
                            ? gameState.activeSprites.player?.[unit.id] 
                            : gameState.activeSprites.rival?.[unit.id];
                    }
                    
                    if (isPlayerViewRevealed && spriteUrl) {
                        const img = document.createElement('img');
                        img.src = spriteUrl;
                        img.alt = unit.name;
                        img.onerror = () => { cellContent.textContent = unit.symbol; };
                        cellContent.appendChild(img);
                    } else {
                        cellContent.textContent = isPlayerViewRevealed ? unit.symbol : '❓';
                    }

                    if (gameState.cheatModeActive && unit.owner === RIVAL_ID && !unit.revealed) {
                        cellContent.classList.add('cheated-reveal');
                    }
                    if (unit.name !== 'Water') {
                         if (!spriteUrl || !isPlayerViewRevealed) { // only add color if no sprite
                            cell.classList.add(unit.owner === PLAYER_ID ? 'player-unit' : 'rival-unit');
                         }
                    }
                    if(isPlayerViewRevealed) {
                        if (unit.name.includes('Castle') && !spriteUrl) cell.classList.add('castle');
                        if (unit.name === 'Mine' && !spriteUrl) cell.classList.add('mine');
                    }
                     if(unit.name === 'Water') {
                         cell.classList.add('water');
                         if (gameState.activeSprites.general?.water) {
                            cell.style.backgroundImage = `url('${gameState.activeSprites.general.water}')`;
                            cell.style.backgroundColor = 'transparent';
                         }
                     }
                    if (unit.owner === RIVAL_ID && !isPlayerViewRevealed) {
                        cell.classList.add('unknown-rival');
                    }
                }
                
                if (gameState.selectedUnit && gameState.selectedUnit.r === r && gameState.selectedUnit.c === c) {
                    cell.classList.add('selected');
                }

                if (gameState.lastMove) {
                    if (gameState.lastMove.from.r === r && gameState.lastMove.from.c === c) cell.classList.add('last-move-from');
                    if (gameState.lastMove.to.r === r && gameState.lastMove.to.c === c) cell.classList.add('last-move-to');
                }

                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    cell.classList.add(move.isAttack ? 'attack-move' : 'valid-move');
                }

                cell.appendChild(cellContent);
                dom.gameBoard.appendChild(cell);
            }
        }
    }
    
    /**
     * Renders all other UI elements like indicators, counts, and messages.
     */
    function renderUI() {
        // Unit counts
        let pCount = 0, rCount = 0;
        for (const row of gameState.grid) for (const unit of row) {
            if (unit && !unit.immobile && unit.name !== 'Water') {
                if (unit.owner === PLAYER_ID) pCount++; else rCount++;
            }
        }
        dom.playerUnitCountEl.textContent = pCount;
        dom.rivalUnitCountEl.textContent = rCount;

        // Turn indicator
        if (gameState.gameOver) {
            dom.turnIndicator.textContent = "Game Over";
            dom.turnIndicator.className = "text-lg text-yellow-400";
            dom.playerStatusPanel.classList.remove('turn-active');
            dom.rivalStatusPanel.classList.remove('turn-active');
        } else {
            dom.turnIndicator.textContent = gameState.currentPlayer === PLAYER_ID ? "Player's Turn" : "Rival's Turn";
            dom.turnIndicator.className = `text-lg ${gameState.currentPlayer === PLAYER_ID ? 'text-blue-400' : 'text-red-400'}`;
            dom.playerStatusPanel.classList.toggle('turn-active', gameState.currentPlayer === PLAYER_ID);
            dom.rivalStatusPanel.classList.toggle('turn-active', gameState.currentPlayer === RIVAL_ID);
        }
    }

    function renderSelectedUnitInfo() {
        const panel = dom.unitInfoPanel;
        const unit = gameState.selectedUnit;

        if (unit) {
            panel.innerHTML = `
                <h3 class="font-bold text-white">${unit.name}</h3>
                <p class="text-gray-300 text-xs">${unit.description}</p>
            `;
        } else {
            panel.innerHTML = `<p class="text-gray-400">Select a unit to see its details.</p>`;
        }
    }
    
    /**
     * Displays a message in the main message area.
     * @param {string} text - The message to display.
     */
    function showMessage(text) {
        dom.messageArea.textContent = text;
    }

    /**
     * Adds a message to the scrolling log panel.
     * @param {string} message - The message content (HTML is allowed).
     * @param {string} [type='info'] - 'combat' or 'reveal' for special styling.
     */
    function logMessage(message, type = 'info') {
        const p = document.createElement('p');
        p.innerHTML = message;
        if(type === 'combat') p.className = 'text-yellow-400';
        if(type === 'reveal') p.className = 'text-cyan-400';
        dom.logContainer.appendChild(p);
        dom.logContainer.scrollTop = dom.logContainer.scrollHeight;
    }

    // --- GAME ACTIONS & LOGIC ---

    /**
     * The main entry point for starting a game.
     * @param {boolean} isSimulation - Whether to start in AI vs AI mode.
     */
    function startGame(isSimulation = false) {
        resetGameState();
        gameState.simulationActive = isSimulation;
        gameState.aiDifficulty = dom.aiDifficultySelector.value;
        dom.logContainer.innerHTML = '';
        
        if (!setupBoardFromComposition()) return;

        setControlsState(isSimulation);
        soundEngine.play('newGame');
        
        if (isSimulation) {
            logMessage('--- AI vs AI SIMULATION STARTED ---');
            showMessage('Simulation running...');
            setTimeout(runAITurn, 1000);
        } else {
            logMessage(`New game started. Mode: ${gameState.ruleset}. AI is ${dom.aiDifficultySelector.value}.`);
            showMessage("Your turn. Select a unit.");
        }
        
        dom.modal.classList.add('hidden');
        render();
    }
    
    /**
     * Selects a unit, updating the game state.
     * @param {number} r - Row of the unit.
     * @param {number} c - Column of the unit.
     */
    function selectUnit(r, c) {
        gameState.selectedUnit = gameState.grid[r][c];
        showMessage(`Selected ${gameState.selectedUnit.name}. Choose a destination.`);
        render();
        renderSelectedUnitInfo();
    }

    /**
     * Deselects the current unit.
     */
    function deselectUnit() {
        gameState.selectedUnit = null;
        showMessage("Your turn. Select a unit.");
        render();
        renderSelectedUnitInfo();
    }
    
    /**
     * Core logic for attempting a move, which leads to combat or position change.
     * @param {object} unit - The unit being moved.
     * @param {object} move - The move object {r, c, isAttack, target}.
     */
    async function attemptMove(unit, move) {
        gameState.isAnimating = true;
        gameState.selectedUnit = null; // Deselect immediately
        const fromR = unit.r, fromC = unit.c;

        // --- Animate the move ---
        const fromCell = document.querySelector(`.cell[data-r='${fromR}'][data-c='${fromC}']`);
        const toCell = document.querySelector(`.cell[data-r='${move.r}'][data-c='${move.c}']`);
        const fromCellContent = fromCell.querySelector('.cell-content');
        const fromRect = fromCell.getBoundingClientRect();
        const toRect = toCell.getBoundingClientRect();
        fromCellContent.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top}px)`;
        fromCellContent.style.zIndex = '20';
        await new Promise(resolve => setTimeout(resolve, 300)); // Animation duration
        
        // --- Update State After Animation ---
        const turnPrefix = gameState.currentPlayer === PLAYER_ID ? `${gameState.turnNumber}. ` : `${gameState.turnNumber}... `;
        logMessage(`${turnPrefix}${unit.owner}'s ${unit.name}(${unit.symbol}) moves ${getCoordName(unit.r, unit.c)}→${getCoordName(move.r, move.c)}.`);
        gameState.lastMove = { from: {r: fromR, c: fromC}, to: {r: move.r, c: move.c} };
        
        if (move.isAttack) {
            handleCombat(unit, move.target);
        } else {
            showMessage(`${unit.name} moved.`);
            gameState.grid[move.r][move.c] = unit;
            gameState.grid[fromR][fromC] = null;
            unit.r = move.r; unit.c = move.c;
        }

        render();
        renderSelectedUnitInfo();
        await new Promise(r => setTimeout(r, gameState.simulationActive ? 100 : 300));

        await checkFrontToFrontCombat();
        
        gameState.isAnimating = false;
        
        if (checkVictory()) return;
        
        switchTurn();
    }
    
    /**
     * Handles the logic for combat between two units.
     * @param {object} attacker - The attacking unit.
     * @param {object} defender - The defending unit.
     */
    function handleCombat(attacker, defender) {
        soundEngine.play('fightStart');
        const reveal = u => { 
            if (!u.revealed) logMessage(`${gameState.turnNumber}. ${u.owner}'s unit at ${getCoordName(u.r,u.c)} is revealed as a ${u.name}!`, 'reveal'); 
            u.revealed = u.aiRevealed = true; 
            return `${u.name}(${u.symbol})`; 
        };
        const attackerId = reveal(attacker), defenderId = reveal(defender);
        logMessage(`${gameState.turnNumber}. ${attackerId} attacks ${defenderId}!`, 'combat');
        
        let msg = '', defeated = [];
        const { r: attR, c: attC } = attacker;
        const { r: defR, c: defC } = defender;

        if (defender.name.includes('Castle')) {
            msg = 'Castle captured!'; 
            gameState.gameOver = true;
            gameState.grid[defR][defC] = attacker;
            gameState.grid[attR][attC] = null;
            attacker.r = defR; attacker.c = defC;
        } else if (defender.name === 'Mine') {
            if (attacker.name === 'Engineer') {
                msg = 'Mine defused!'; 
                defeated.push(defender); 
                gameState.grid[defR][defC] = attacker; 
                gameState.grid[attR][attC] = null; 
                attacker.r = defR; attacker.c = defC;
            } else {
                msg = `${attackerId} destroyed by mine!`; 
                defeated.push(attacker); 
                gameState.grid[attR][attC] = null;
            }
        } else if (attacker.level > defender.level) {
            msg = `${defenderId} defeated.`; 
            defeated.push(defender);
            gameState.grid[defR][defC] = null; // Defender removed
            if (gameState.ruleset !== 'stratego') { // Attacker moves in original rules
                gameState.grid[defR][defC] = attacker;
                gameState.grid[attR][attC] = null;
                attacker.r = defR; attacker.c = defC;
            }
        } else if (attacker.level < defender.level) {
            msg = `${attackerId} defeated.`; 
            defeated.push(attacker);
            gameState.grid[attR][attC] = null;
        } else { // Equal rank
            msg = 'Both units destroyed!'; 
            defeated.push(attacker, defender);
            gameState.grid[attR][attC] = null;
            gameState.grid[defR][defC] = null;
        }
        
        // In Stratego, surviving attacker becomes hidden again
        if (gameState.ruleset === 'stratego' && gameState.grid[attR]?.[attC] === attacker) {
            attacker.revealed = false;
            attacker.aiRevealed = false; // For simplicity, AI also forgets
        }

        showMessage(msg); 
        defeated.forEach(showDefeatedUnit);
    }

    /**
     * Checks for and resolves passive combat between adjacent rival/player units (Reveal Your Rank only).
     */
    async function checkFrontToFrontCombat() {
        if (gameState.ruleset !== 'reveal') return;

        const pairs = [];
        // Check for player unit below a rival unit
        for (let r = 0; r < ROWS - 1; r++) {
            for (let c = 0; c < COLS; c++) {
                const upperUnit = gameState.grid[r][c];
                const lowerUnit = gameState.grid[r + 1][c];
                
                if (upperUnit && lowerUnit && 
                    !upperUnit.immobile && !lowerUnit.immobile &&
                    upperUnit.owner === RIVAL_ID && lowerUnit.owner === PLAYER_ID) {
                     pairs.push([upperUnit, lowerUnit]);
                }
            }
        }
        
        if (pairs.length === 0) return;
        
        showMessage('Front-to-front combat!');
        await new Promise(r => setTimeout(r, 500));
        
        let combatHappened = false;
        for (const [rivalUnit, playerUnit] of pairs) {
            // Re-check if units still exist before combat, in case one was destroyed in another pair this turn
            if (!gameState.grid[rivalUnit.r][rivalUnit.c] || !gameState.grid[playerUnit.r][playerUnit.c]) continue; 
            
            const reveal = u => { if(!u.revealed) u.revealed = u.aiRevealed = true; return `${u.name}(${u.symbol})`; };
            const rivalId = reveal(rivalUnit);
            const playerId = reveal(playerUnit);
            
            let log, defeated = [];
            if (rivalUnit.level > playerUnit.level) {
                defeated.push(playerUnit); 
                log = `Front-to-front: ${rivalId} defeats ${playerId}!`;
            } else if (playerUnit.level > rivalUnit.level) {
                defeated.push(rivalUnit); 
                log = `Front-to-front: ${playerId} defeats ${rivalId}!`;
            } else {
                defeated.push(rivalUnit, playerUnit); 
                log = `Front-to-front: ${rivalId} & ${playerId} perish!`;
            }
            
            logMessage(`${gameState.turnNumber}. ${log}`, 'combat');
            defeated.forEach(u => {
                showDefeatedUnit(u);
                gameState.grid[u.r][u.c] = null;
            });
            combatHappened = true;
        }
        
        if(combatHappened) {
            showMessage('Combat resolved!');
            render();
            await new Promise(r => setTimeout(r, 1200));
        }
    }
    
    /**
     * Switches the current turn and triggers AI if necessary.
     */
    function switchTurn() {
        gameState.currentPlayer = (gameState.currentPlayer === PLAYER_ID) ? RIVAL_ID : PLAYER_ID;
        if (gameState.currentPlayer === PLAYER_ID) {
            gameState.turnNumber++;
        }
        
        // Check for "No Valid Moves" loss condition before continuing
        if (!canPlayerMove(gameState.currentPlayer)) {
            const winner = gameState.currentPlayer === PLAYER_ID ? 'Rival' : 'Player';
            const loser = gameState.currentPlayer === PLAYER_ID ? 'Player' : 'Rival';
            endGame(`${winner} Wins!`, `${loser} has no valid moves and loses the game.`);
            return;
        }

        renderUI();

        if (gameState.gameOver) return;

        if (gameState.simulationActive) {
            setTimeout(runAITurn, parseInt(dom.simSpeedSelector.value));
        } else if (gameState.currentPlayer === RIVAL_ID) {
            showMessage("Rival's turn...");
            setTimeout(runAITurn, 1000);
        } else {
            showMessage("Your turn. Select a unit.");
        }
    }

    // --- INPUT HANDLING ---

    /**
     * Main handler for all clicks on the game board. It translates clicks into game actions.
     */
    function handleCellClick(e) {
        if (gameState.gameOver || gameState.isAnimating || 
            (gameState.currentPlayer !== PLAYER_ID && !gameState.simulationActive)) return;
            
        const cell = e.target.closest('.cell');
        if (!cell) return;

        const r = parseInt(cell.dataset.r);
        const c = parseInt(cell.dataset.c);
        const unitAtClick = gameState.grid[r][c];

        if (gameState.selectedUnit) {
            const move = getValidMoves(gameState.selectedUnit).find(m => m.r === r && m.c === c);
            if (move) {
                attemptMove(gameState.selectedUnit, move);
            } else if (unitAtClick && unitAtClick.owner === PLAYER_ID && !unitAtClick.immobile) {
                selectUnit(r, c); // Switch selection
            } else {
                deselectUnit();
            }
        } else if (unitAtClick && unitAtClick.owner === PLAYER_ID) {
            if (!unitAtClick.immobile) {
                selectUnit(r, c);
            } else {
                showMessage(`${unitAtClick.name} cannot move.`);
            }
        }
    }

    // --- UTILITIES & HELPERS ---
    
    /**
     * Creates a new unit object.
     * @param {object} unitDef - The unit definition from the UNITS constant.
     * @param {string} owner - The owner of the unit ('player' or 'rival').
     * @returns {object} The new unit object.
     */
    const createUnit = (unitDef, owner) => ({ ...unitDef, owner, revealed: false, aiRevealed: false });

    /**
     * Shuffles an array in place.
     * @param {Array} a - The array to shuffle.
     */
    const shuffleArray = a => { for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} };
    
    /**
     * Converts row/column to algebraic notation.
     * @param {number} r - Row index.
     * @param {number} c - Column index.
     * @returns {string} Coordinate name (e.g., "A12").
     */
    const getCoordName = (r,c) => `${String.fromCharCode(65+c)}${ROWS-r}`;

    /**
     * Creates a temporary element to animate a defeated unit fading out.
     * @param {object} unit - The unit that was defeated.
     */
    function showDefeatedUnit(unit) {
        if (!unit) return;
        soundEngine.play('death');
        const boardRect = dom.gameBoard.getBoundingClientRect();
        if (!boardRect.width || !boardRect.height) return;

        const cellWidth = boardRect.width / COLS;
        const cellHeight = boardRect.height / ROWS;

        const fireSpriteUrl = gameState.activeSprites.general?.fire;

        // Only show fire animation if the sprite is available
        if (fireSpriteUrl) {
            const fireAnim = document.createElement('img');
            fireAnim.src = fireSpriteUrl;
            fireAnim.style.cssText = `
                position: fixed;
                left: ${boardRect.left + unit.c * cellWidth}px;
                top: ${boardRect.top + unit.r * cellHeight}px;
                width: ${cellWidth}px;
                height: ${cellHeight}px;
                z-index: 50;
                transform: scale(0.8);
                transition: opacity 0.5s ease-out, transform 0.5s ease-out;
            `;
            document.body.appendChild(fireAnim);
            
            requestAnimationFrame(() => {
                fireAnim.style.opacity = '0';
                fireAnim.style.transform = 'scale(1.2)';
            });
            setTimeout(() => fireAnim.remove(), 500);
        }
    }
    
    /**
     * Creates the coordinate labels around the board.
     */
    function setupCoordinates() {
        const colLabelsTop = document.getElementById('col-labels');
        const colLabelsBottom = document.getElementById('col-labels-bottom');
        const rowLabelsLeft = document.getElementById('row-labels');
        const rowLabelsRight = document.getElementById('row-labels-right');
        
        colLabelsTop.innerHTML = '';
        colLabelsBottom.innerHTML = '';
        rowLabelsLeft.innerHTML = '';
        rowLabelsRight.innerHTML = '';

        for (let c = 0; c < COLS; c++) {
            const char = String.fromCharCode(65 + c);
            colLabelsTop.innerHTML += `<div class="coord-item">${char}</div>`;
            colLabelsBottom.innerHTML += `<div class="coord-item">${char}</div>`;
        }
        for (let r = 0; r < ROWS; r++) {
            const num = ROWS - r;
            rowLabelsLeft.innerHTML += `<div class="coord-item">${num}</div>`;
            rowLabelsRight.innerHTML += `<div class="coord-item">${num}</div>`;
        }
    }
    
    /**
     * Gets all valid moves for a given unit based on the current ruleset.
     * @param {object} unit - The unit to calculate moves for.
     * @returns {Array} A list of valid move objects.
     */
    function getValidMoves(unit) {
        if (!unit || unit.immobile) return [];
        const moves = [];
        const { r, c, owner } = unit;
        
        const allDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // N, S, W, E

        if (unit.name === 'Scout') {
            for (const [dr, dc] of allDirections) {
                for (let i = 1; ; i++) {
                    const newR = r + dr * i, newC = c + dc * i;
                    if (newR < 0 || newR >= ROWS || newC < 0 || newC >= COLS) break;
                    const target = gameState.grid[newR][newC];
                    if (target) {
                        if (gameState.ruleset === 'stratego' && target.owner !== owner && target.name !== 'Water') {
                             moves.push({r: newR, c: newC, isAttack: true, target});
                        }
                        break;
                    }
                    moves.push({ r: newR, c: newC, isAttack: false, target: null });
                }
            }
        } else { // Normal units
            for (const [dr, dc] of allDirections) {
                const newR = r + dr, newC = c + dc;
                if (newR >= 0 && newR < ROWS && newC >= 0 && newC < COLS) {
                    const target = gameState.grid[newR][newC];
                    if (!target) {
                        moves.push({r: newR, c: newC, isAttack: false, target: null});
                    } else if (gameState.ruleset === 'stratego' && target.owner !== owner && target.name !== 'Water') {
                        moves.push({r: newR, c: newC, isAttack: true, target});
                    }
                }
            }
        }
        return moves;
    }
    
    /**
     * Checks if a player has any possible moves.
     * @param {string} owner - The player to check ('player' or 'rival').
     * @returns {boolean} True if the player has at least one move.
     */
    function canPlayerMove(owner) {
        for (const row of gameState.grid) {
            for (const unit of row) {
                if (unit && unit.owner === owner && !unit.immobile) {
                    if (getValidMoves(unit).length > 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Checks if the game has been won and ends it if so.
     * @returns {boolean} True if the game is over.
     */
    function checkVictory() {
        let pCastle = false, rCastle = false;
        for(const row of gameState.grid) for(const u of row) if(u) {
            if(u.name.includes('Castle')) { 
                if(u.owner === PLAYER_ID) pCastle=true; else rCastle=true; 
            }
        }
        if(!rCastle) { endGame('Player Wins!', "Rival's Castle has been captured!"); return true; }
        if(!pCastle) { endGame('Rival Wins!', 'Your Castle has been captured.'); return true; }
        return false;
    }

    /**
     * Ends the game and displays the result.
     * @param {string} title - The title of the modal.
     * @param {string} bodyText - The body text of the modal.
     * @param {boolean} [simStopped=false] - If the sim was halted manually.
     */
    function endGame(title, bodyText, simStopped = false) {
        gameState.gameOver = true;
        gameState.simulationActive = false;
        if (!simStopped) {
            if(title.toLowerCase().includes('win')) soundEngine.play('victory');
            logMessage(`--- GAME OVER: ${title} ---`);
            dom.modalTitle.textContent = title;
            
            let modalContent = '';
            const victoryImgUrl = gameState.activeSprites.general?.victory;
            if (victoryImgUrl && title.toLowerCase().includes('win')) {
                modalContent += `<img src="${victoryImgUrl}" alt="Victory" class="w-64 h-64 mx-auto mb-4">`;
            }
            modalContent += bodyText;
            
            dom.modalBody.innerHTML = modalContent;
            dom.modalBody.classList.remove('modal-body-scrollable');
            dom.modal.classList.remove('hidden');
        }
        setControlsState(false);
        renderUI();
    }
    
    // --- SETUP AND INITIALIZATION ---

    /**
     * Reads the 'Setup' tab form to get the player's desired army.
     * @returns {Array|null} Army composition array or null if invalid.
     */
    function getArmyCompositionFromSetup() {
        const composition = [];
        const compositionSource = dom.rulesetSelector.value === 'stratego' ? STRATEGO_ARMY_COMPOSITION : REVEAL_ARMY_COMPOSITION;
        const maxUnits = compositionSource.reduce((sum, item) => sum + (item.unit.name.includes('Castle') ? 0 : item.quantity), 0);
        
        let total = 0;
        dom.armySetupForm.querySelectorAll('input').forEach(input => {
            const quantity = parseInt(input.value) || 0;
            total += quantity;
            if (quantity > 0) {
                const unitDef = Object.values(UNITS).find(u => u.id === input.dataset.unitId);
                composition.push({ unit: unitDef, quantity });
            }
        });

        if (total > maxUnits) {
            dom.modalTitle.textContent = "Invalid Army";
            dom.modalBody.innerHTML = `Total unit count cannot exceed ${maxUnits}. Please adjust your army composition in the 'Setup' tab.`;
            dom.modal.classList.remove('hidden');
            return null;
        }
        composition.unshift({ unit: UNITS.CASTLE, quantity: 1 });
        return composition;
    }
    
    /**
     * Populates the board with units based on the setup form.
     * @returns {boolean} True if setup was successful.
     */
    function setupBoardFromComposition() {
        const armyComposition = getArmyCompositionFromSetup();
        if (!armyComposition) return false;

        const placeArmy = (owner, startRow, endRow) => {
            const armyList = armyComposition.flatMap(comp => comp.unit.name.includes('Castle') ? [] : Array(comp.quantity).fill(comp.unit));
            shuffleArray(armyList);
            
            const castle = { ...createUnit(UNITS.CASTLE, owner), r: owner === PLAYER_ID ? ROWS - 1 : 0, c: Math.floor(Math.random() * COLS) };
            gameState.grid[castle.r][castle.c] = castle;

            const availableSpots = [];
            for (let r = startRow; r < endRow; r++) for (let c = 0; c < COLS; c++) {
                if (!gameState.grid[r][c]) availableSpots.push({r, c});
            }
            shuffleArray(availableSpots);
            
            for (let i = 0; i < armyList.length && i < availableSpots.length; i++) {
                const spot = availableSpots[i];
                gameState.grid[spot.r][spot.c] = { ...createUnit(armyList[i], owner), ...spot };
            }
        };

        placeArmy(PLAYER_ID, ROWS - 4, ROWS);
        placeArmy(RIVAL_ID, 0, 4);

        const waterCoordinates = [
            { r: 5, c: 0 }, { r: 6, c: 0 }, // A7, A6
            { r: 5, c: 1 }, { r: 6, c: 1 }, // B7, B6
            { r: 5, c: 3 }, { r: 6, c: 3 }, // D7, D6
            { r: 5, c: 5 }, { r: 6, c: 5 }, // F7, F6
            { r: 5, c: 7 }, { r: 6, c: 7 }, // H7, H6
            { r: 5, c: 8 }, { r: 6, c: 8 }, // I7, I6
        ];

        for (const {r, c} of waterCoordinates) {
            if (!gameState.grid[r][c]) {
                gameState.grid[r][c] = { ...UNITS.WATER, owner: 'neutral', r, c, revealed: true, aiRevealed: true };
            }
        }
        
        return true;
    }
    
    // --- AI LOGIC ---
    async function runAITurn() {
        if (gameState.gameOver) return;
        
        const units = [];
        for (const row of gameState.grid) for (const unit of row) {
            if (unit && unit.owner === gameState.currentPlayer && !unit.immobile) {
                units.push(unit);
            }
        }
        
        let bestMove = null, maxScore = -Infinity;
        for (const unit of units) {
            for (const move of getValidMoves(unit)) {
                // This is a simplified scoring. A real AI would look ahead.
                let score = Math.random() * 5; 
                if (move.isAttack) {
                    const target = move.target;
                    const isTargetRevealed = target.aiRevealed;
                    if (!isTargetRevealed) {
                        score += (gameState.aiDifficulty === 'high') ? 20 : 10;
                    } else {
                         if (target.name.includes('Castle')) score = 1000;
                         else if (target.name === 'Mine') score += (unit.name === 'Engineer') ? 50 : -50;
                         else if (unit.level > target.level) score += 25 + (target.level * 2);
                         else if (unit.level < target.level) score -= 30;
                         else score += 5;
                    }
                } else { // non-attack move
                    score += gameState.ruleset === 'stratego' ? 0 : unit.r; // Simple incentive to move forward for Rival in original rules
                    if (gameState.aiDifficulty === 'high' && unit.name === 'Scout') {
                         const directions = [[-1,0],[1,0],[0,-1],[0,1]];
                         for(const [dr, dc] of directions) {
                            const neighbor = gameState.grid[move.r+dr]?.[move.c+dc];
                            if(neighbor && neighbor.owner !== unit.owner && !neighbor.aiRevealed) {
                                score += 25; // High reward for scouting unknown units
                            }
                        }
                    }
                }

                if (score > maxScore) {
                    maxScore = score;
                    bestMove = { unit, move };
                }
            }
        }
        
        if (bestMove) {
            await attemptMove(bestMove.unit, bestMove.move);
        } else {
            switchTurn(); // No moves available
        }
    }
    
    // --- EVENT LISTENERS & INITIAL SETUP ---
    
    function setControlsState(isSimulating) {
        dom.rulesetSelector.disabled = isSimulating;
        dom.aiDifficultySelector.disabled = isSimulating;
        dom.resetButton.disabled = isSimulating;
        dom.armySetupForm.querySelectorAll('input').forEach(i => i.disabled = isSimulating);
        dom.simulateButton.textContent = isSimulating ? 'Stop' : 'Simulate';
        dom.simulateButton.classList.toggle('bg-purple-500', !isSimulating);
        dom.simulateButton.classList.toggle('hover:bg-purple-600', !isSimulating);
        dom.simulateButton.classList.toggle('bg-red-500', isSimulating);
        dom.simulateButton.classList.toggle('hover:bg-red-600', isSimulating);
    }
    
    function updateTotalSetupDisplay() {
        const ruleset = dom.rulesetSelector.value;
        const compositionSource = ruleset === 'stratego' ? STRATEGO_ARMY_COMPOSITION : REVEAL_ARMY_COMPOSITION;
        const maxUnits = compositionSource.reduce((sum, item) => sum + (item.unit.name.includes('Castle') ? 0 : item.quantity), 0);
        
        let total = 0;
        dom.armySetupForm.querySelectorAll('input').forEach(input => {
            total += parseInt(input.value) || 0;
        });

        const totalContainerP = dom.armySetupForm.nextElementSibling;
        if (totalContainerP) {
            totalContainerP.innerHTML = `Total Units: <span id="setup-total-units" class="${total > maxUnits ? 'text-red-500' : ''}">${total}</span> / ${maxUnits}`;
        }
        
        const isInvalid = total > maxUnits;
        dom.resetButton.disabled = isInvalid;
        dom.simulateButton.disabled = isInvalid;
    }

    function populateSetupForm() {
        const ruleset = dom.rulesetSelector.value;
        const compositionSource = ruleset === 'stratego' ? STRATEGO_ARMY_COMPOSITION : REVEAL_ARMY_COMPOSITION;
        
        dom.armySetupForm.innerHTML = '';
        compositionSource.forEach(item => {
            if (item.unit.name.includes('Castle')) return;
            const div = document.createElement('div');
            div.className = 'flex justify-between items-center';
            const displayName = item.unit.level > 1 && item.unit.level < 10 ? `${item.unit.name} (${item.unit.symbol})` : (item.unit.id === 'knight_1' ? 'Knight (K1)' : item.unit.name);
            div.innerHTML = `<label for="setup-${item.unit.id}" class="truncate pr-2">${displayName}</label><input type="number" id="setup-${item.unit.id}" data-unit-id="${item.unit.id}" value="${item.quantity}" min="0" max="10" class="w-16 bg-gray-600 text-white p-1 rounded">`;
            dom.armySetupForm.appendChild(div);
        });
        
        updateTotalSetupDisplay();
    }
    
    function populateSpriteForm() {
        dom.spriteSetupForm.innerHTML = '';
        const allAssets = [...Object.values(UNITS), {id: 'grass', name: 'Grass Tile'}, {id: 'water', name: 'Water Tile'}, {id: 'fire', name: 'Fire Animation'}, {id: 'victory', name: 'Victory Image'}];

        allAssets.forEach(asset => {
            if (asset.id === 'water' && asset.name === 'Water') return;
            const div = document.createElement('div');
            div.className = 'flex justify-between items-center gap-2';
            const displayName = asset.name.includes('Knight') ? `${asset.name} (${asset.symbol})` : asset.name;
            div.innerHTML = `
                <label for="sprite-${asset.id}" class="truncate text-xs">${displayName}</label>
                <input type="url" id="sprite-${asset.id}" data-unit-id="${asset.id}" placeholder="Image URL" class="w-48 bg-gray-600 text-white p-1 rounded text-xs">
            `;
            dom.spriteSetupForm.appendChild(div);
        });
    }

    async function checkAsset(url) {
        return new Promise(resolve => {
            if (!url || typeof url !== 'string') return resolve(false);
            const img = new Image();
            img.onload = () => resolve(true);
            img.onerror = () => resolve(false);
            img.src = url;
        });
    }
    
    async function checkSoundAsset(url) {
        return new Promise(resolve => {
            if (!url || typeof url !== 'string') return resolve(false);
            const audio = new Audio();
            const timeout = setTimeout(() => resolve(false), 2000); // 2s timeout
            audio.oncanplaythrough = () => { clearTimeout(timeout); resolve(true); };
            audio.onerror = () => { clearTimeout(timeout); resolve(false); };
            audio.src = url;
        });
    }

    async function populateSpriteInfo() {
        const listContainer = document.createElement('div');
        listContainer.className = 'space-y-1 text-sm modal-body-scrollable';
        const selectedTheme = dom.spritePresetSelector.value;

        if (selectedTheme === 'default' || selectedTheme === 'custom') {
            listContainer.innerHTML = `<p class="text-gray-500">Asset list is only available for pre-defined themes.</p>`;
            return listContainer;
        }

        const themeAssets = getThemeAssets(selectedTheme);

        const createSection = async (title, assets, isSound = false) => {
            if (!assets || Object.keys(assets).length === 0) return '';
            let sectionHtml = `<h4 class="font-bold text-lg mt-2">${title}</h4>`;
            
            for (const key in assets) {
                const url = assets[key];
                const isLoaded = isSound ? (await checkSoundAsset(url) ? '🔊' : '❌') : (await checkAsset(url) ? '✅' : '❌');
                
                let name = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                const unit = Object.values(UNITS).find(u => u.id === key);
                if (unit) { name = unit.name.includes('Knight') ? `${unit.name} (${unit.symbol})` : unit.name; } 
                else {
                    if (key === 'grass') name = 'Grass Tile'; if (key === 'water') name = 'Water Tile';
                    if (key === 'fire') name = 'Fire Animation'; if (key === 'victory') name = 'Victory Image';
                }

                sectionHtml += `
                    <div>
                        <a href="${url}" target="_blank" class="text-sky-400 hover:text-sky-300" title="Open asset in new tab">
                           ${isLoaded} - ${name}
                        </a>
                    </div>`;
            }
            return sectionHtml;
        };

        listContainer.innerHTML += await createSection('General Sprites', themeAssets.general);
        listContainer.innerHTML += await createSection('Player Sprites', themeAssets.player);
        listContainer.innerHTML += await createSection('Rival Sprites', themeAssets.rival);
        listContainer.innerHTML += await createSection('Sound Assets', themeAssets.sounds, true);
        
        return listContainer;
    }

    function getActiveSprites() {
        const preset = dom.spritePresetSelector.value;
        if (preset === 'default') return {};
        if (preset === 'custom') {
            const urls = { general: {}, player: {}, rival: {} };
            dom.spriteSetupForm.querySelectorAll('input').forEach(input => {
                if (input.value) {
                     urls.general[input.dataset.unitId] = input.value;
                     urls.player[input.dataset.unitId] = input.value;
                     urls.rival[input.dataset.unitId] = input.value;
                }
            });
            return urls;
        }
        return getThemeAssets(preset);
    }

    function handlePresetChange() {
        const preset = dom.spritePresetSelector.value;
        dom.customSpriteInputsWrapper.classList.toggle('hidden', preset !== 'custom');
        setupSoundEngine();
        
        if (gameState.grid) {
            gameState.activeSprites = getActiveSprites();
            render();
        }
    }
    
    function showDebugModal() {
        dom.modalTitle.textContent = 'Debug Menu';
        const body = document.createElement('div');
        body.className = 'flex flex-col gap-2';
        const states = ['Player Wins', 'Rival Wins', 'Draw'];
        states.forEach(state => {
            const btn = document.createElement('button');
            btn.textContent = `Trigger: ${state}`;
            btn.className = 'bg-gray-200 hover:bg-gray-300 p-2 rounded';
            btn.onclick = () => {
                endGame(state, `Game state forced to "${state}" by debug menu.`);
            };
            body.appendChild(btn);
        });
        dom.modalBody.innerHTML = '';
        dom.modalBody.appendChild(body);
        dom.modalBody.classList.remove('modal-body-scrollable');
        dom.modal.classList.remove('hidden');
    }
    
    async function showSpriteInfoModal() {
        dom.modalTitle.textContent = 'Sprite Asset Info';
        dom.modalBody.innerHTML = '<p>Loading asset status...</p>'; // Loading state
        dom.modalBody.classList.add('modal-body-scrollable');
        dom.modal.classList.remove('hidden');
        const content = await populateSpriteInfo();
        dom.modalBody.innerHTML = '';
        dom.modalBody.appendChild(content);
    }

    function stopSimulation() {
        endGame('Simulation Halted', 'The simulation was stopped by the user.', true);
    }
    
    function setupSoundEngine() {
        const theme = dom.spritePresetSelector.value;
        const themeAssets = getThemeAssets(theme);
        const sounds = themeAssets.sounds;
        soundEngine.audio = {};
        if (sounds) {
            for (const key in sounds) {
                soundEngine.audio[key] = new Audio(sounds[key]);
            }
        }
        
        soundEngine.play = (soundName) => {
            if (soundEngine.audio[soundName]) {
                soundEngine.audio[soundName].currentTime = 0;
                soundEngine.audio[soundName].play().catch(e => console.log("Sound play interrupted."));
            }
        };
    }

    async function showSoundInfoModal() {
        dom.modalTitle.textContent = 'Sound Asset Info';
        let bodyContent = `<div class="space-y-1 text-sm modal-body-scrollable">`;
        const theme = dom.spritePresetSelector.value;
        const themeAssets = getThemeAssets(theme);
        const sounds = themeAssets.sounds;

        if (sounds && Object.keys(sounds).length > 0) {
            for(const key in sounds) {
                const isLoaded = await checkSoundAsset(sounds[key]) ? '🔊' : '❌';
                bodyContent += `<div class="p-2 bg-gray-100 rounded">
                    <a href="${sounds[key]}" target="_blank" class="text-sky-400 hover:text-sky-300">
                       ${isLoaded} - <strong>${key}</strong>
                    </a>
                </div>`;
            }
        } else {
            bodyContent += `<p>No sound assets for this theme.</p>`;
        }
        bodyContent += `</div>`;
        dom.modalBody.innerHTML = bodyContent;
        dom.modalBody.classList.add('modal-body-scrollable');
        dom.modal.classList.remove('hidden');
    }

    function setupUI() {
        setupCoordinates();
        populateSetupForm();
        populateSpriteForm();
        setupSoundEngine();
        
        // --- Event Listeners ---
        dom.gameBoard.addEventListener('click', handleCellClick);
        dom.resetButton.addEventListener('click', () => startGame(false));
        dom.simulateButton.addEventListener('click', () => gameState.simulationActive ? stopSimulation() : startGame(true));
        dom.rulesetSelector.addEventListener('change', populateSetupForm);
        dom.armySetupForm.addEventListener('input', updateTotalSetupDisplay);
        dom.spritePresetSelector.addEventListener('change', handlePresetChange);
        dom.spriteSetupForm.addEventListener('input', handlePresetChange);
        dom.modalCloseButton.addEventListener('click', () => dom.modal.classList.add('hidden'));
        dom.spriteInfoButton.addEventListener('click', showSpriteInfoModal);

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('tab-active'));
                tab.classList.add('tab-active');
                
                const targetId = `tab-content-${tab.dataset.target}`;
                const targetContent = document.getElementById(targetId);
                
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('tab-content-active'));
                
                if (targetContent) {
                    targetContent.classList.add('tab-content-active');
                }
            });
        });

        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            const key = e.key.toLowerCase();
            if (key === 'c' && !gameState.simulationActive) {
                gameState.cheatModeActive = !gameState.cheatModeActive;
                showMessage(`Cheat mode ${gameState.cheatModeActive ? 'enabled' : 'disabled'}.`);
                renderBoard();
            } else if (key === 's') {
                showSoundInfoModal();
            } else if (key === 'd') {
                showDebugModal();
            }
        });
    }

    // --- Let's begin ---
    setupUI();
    startGame(false);

    </script>
</body>
</html>
